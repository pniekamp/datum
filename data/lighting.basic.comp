#version 450 core
#include "bound.glsl"
#include "camera.glsl"
#include "gbuffer.glsl"
#include "transform.glsl"
#include "lighting.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(local_size_x_id = 1, local_size_y_id = 2) in;

layout(constant_id = 46) const uint ShadowSlices = 4;
layout(constant_id = 29) const uint MaxPointLights = 256;
layout(constant_id = 31) const uint MaxEnvironments = 6;
layout(constant_id = 72) const uint MaxTileLights = 48;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 prevview;
  mat4 skyview;
  
  Camera camera;
  
  MainLight mainlight;
  
  uint environmentcount;
  Environment environments[MaxEnvironments];

  float splits[4];
  mat4 shadowview[4];

  uint pointlightcount;
  PointLight pointlights[MaxPointLights];

} scene;

layout(set=0, binding=1) uniform sampler2DArray rt0map;
layout(set=0, binding=2) uniform sampler2DArray rt1map;
layout(set=0, binding=3) uniform sampler2DArray normalmap;
layout(set=0, binding=4) uniform sampler2DArray depthmap;
layout(set=0, binding=5) uniform sampler2DArray ssaomap;
layout(set=0, binding=6) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=7) uniform samplerCube envmap[MaxEnvironments];
layout(set=0, binding=8) uniform sampler2DArray envbrdfmap;

layout(set=3, binding=1) writeonly uniform image2D dest;

///////////////////////// mainlight_shadow //////////////////////////////////
float mainlight_shadow(MainLight light, vec3 position, vec3 normal)
{
  const float bias[ShadowSlices] = { 0.05, 0.06, 0.10, 0.25 };
  const float spread[ShadowSlices] = { 1.5, 1.2, 1.0, 0.2 };

  for(uint i = 0; i < ShadowSlices; ++i)
  {
    vec3 shadowpos = position + bias[i] * normal;
    vec4 shadowspace = scene.shadowview[i] * vec4(shadowpos, 1);
    
    vec4 texel = vec4(0.5 * shadowspace.xy + 0.5, i, shadowspace.z);

    if (texel.x > 0.0 && texel.x < 1.0 && texel.y > 0.0 && texel.y < 1.0 && texel.w > 0.0 && texel.w < 1.0)
    { 
      float weight = max(4 * max(max(abs(shadowspace.x), abs(shadowspace.y)) - 0.75, 0.0), 500 * max(shadowspace.z - 0.998, 0.0));

      if (i+i < ShadowSlices && weight > 0.0)
      {     
        return mix(shadow_intensity(scene.shadowview[i], shadowpos, i, shadowmap, spread[i]), shadow_intensity(scene.shadowview[i+1], position + bias[i+1] * normal, i+1, shadowmap, spread[i+1]), weight);
      }
      else
      {
        return shadow_intensity(scene.shadowview[i], shadowpos, i, shadowmap, spread[i]);
      }     
    }
  }
  
  return 1.0;
}

///////////////////////// environment  ///////////////////////////////////////
void environment(inout vec3 envdiffuse, inout vec3 envspecular, vec3 position, vec3 normal, vec3 eyevec, Material material)
{
  uint i = 0;

  vec3 diffusedirection = dffuse_dominantdirection(normal, eyevec, material.roughness);
  vec3 speculardirection = specular_dominantdirection(normal, reflect(-eyevec, normal), material.roughness);

  for(uint end = max(scene.environmentcount, 1u) - 1; i < end; ++i)
  {
    vec3 localpos = transform_multiply(scene.environments[i].invtransform, position);
    vec3 localdir = quaternion_multiply(scene.environments[i].invtransform.real, speculardirection);
    
    vec2 hittest = intersections(localpos, localdir, scene.environments[i].halfdim);
    
    if (hittest.y > max(hittest.x, 0.0) && hittest.x < 0)
    { 
      vec3 localray = localpos + hittest.y * localdir;
      float localroughness = clamp(material.roughness * hittest.y / length(localray), 0.0, material.roughness);
    
      envdiffuse = textureLod(envmap[i], diffusedirection * vec3(1, -1, -1), 6.3).rgb;        
      envspecular = textureLod(envmap[i], localray * vec3(1, -1, -1), localroughness * 8.0).rgb;
      return;
    }
  }

  if (scene.environmentcount != 0)
  {
    vec3 localdir = quaternion_multiply(scene.environments[i].invtransform.real, speculardirection);

    envdiffuse = textureLod(envmap[i], diffusedirection * vec3(1, -1, -1), 6.3).rgb;        
    envspecular = textureLod(envmap[i], localdir * vec3(1, -1, -1), material.roughness * 8.0).rgb;
  }
}
  
///////////////////////// main //////////////////////////////////////////////
void main(void)
{ 
  gl_WorkGroupSize;

  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = textureSize(rt0map, 0).xy;//imageSize(dest);
  
  float depth = texelFetch(depthmap, ivec3(xy, 0), 0).z;

  vec4 fragcolor = vec4(0);
  
  if (depth < 1.0)
  {
    vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
    vec3 normal = world_normal(texelFetch(normalmap, ivec3(xy, 0), 0).xyz);
    vec3 eyevec = normalize(scene.camera.position - position);

    Material material = unpack_material(texelFetch(rt0map, ivec3(xy, 0), 0), texelFetch(rt1map, ivec3(xy, 0), 0)); 

    vec2 envbrdf = texture(envbrdfmap, vec3(dot(normal, eyevec), material.roughness, 0.0)).rg;

    float ambientintensity = ambient_intensity(scene.mainlight, ssaomap, xy, viewport);

    float mainlightshadow = mainlight_shadow(scene.mainlight, position, normal);
    
    vec3 envdiffuse = vec3(1);
    vec3 envspecular = vec3(0);

    environment(envdiffuse, envspecular, position, normal, eyevec, material);

    vec3 diffuse = vec3(0);
    vec3 specular = vec3(0);

    env_light(diffuse, specular, material, envdiffuse, envspecular, envbrdf, ambientintensity);
    
    main_light(diffuse, specular, scene.mainlight, normal, eyevec, material, mainlightshadow);
    
    for(uint i = 0, end = scene.pointlightcount; i < end; ++i)
    {
      PointLight pointlight = scene.pointlights[i];

      if (length(pointlight.position - position) < pointlight.attenuation.w)
      {
        point_light(diffuse, specular, pointlight, position, normal, eyevec, material);
      }
    }

    fragcolor = vec4(scene.camera.exposure * ((diffuse + material.emissive) * material.diffuse + specular), 1);
  }

  imageStore(dest, xy, fragcolor);
}

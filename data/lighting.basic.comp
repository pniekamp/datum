#version 450 core
#include "camera.glsl"
#include "gbuffer.glsl"
#include "transform.glsl"
#include "lighting.glsl"

layout(local_size_x_id = 74, local_size_y_id = 75) in;

layout(constant_id = 46) const uint ShadowSlices = 4;
layout(constant_id = 29) const uint MaxPointLights = 256;
layout(constant_id = 31) const uint MaxEnvironments = 6;
layout(constant_id = 72) const uint MaxTileLights = 48;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 prevview;
  mat4 skyview;
  
  Camera camera;
  
  MainLight mainlight;
  
  uint environmentcount;
  Environment environments[MaxEnvironments];

  mat4 shadowview[ShadowSlices];

  uint pointlightcount;
  PointLight pointlights[MaxPointLights];

} scene;

layout(set=0, binding=1) uniform sampler2DArray rt0map;
layout(set=0, binding=2) uniform sampler2DArray rt1map;
layout(set=0, binding=3) uniform sampler2DArray normalmap;
layout(set=0, binding=4) uniform sampler2DArray depthmap;
layout(set=0, binding=5) uniform sampler2DArray ssaomap;
layout(set=0, binding=6) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=7) uniform samplerCube envmap[MaxEnvironments];
layout(set=0, binding=8) uniform sampler2DArray envbrdfmap;

layout(set=3, binding=1) writeonly uniform image2D dest;

///////////////////////// main //////////////////////////////////////////////
void main(void)
{ 
  gl_WorkGroupSize;

  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = imageSize(dest);
  
  float depth = texelFetch(depthmap, ivec3(xy, 0), 0).z;
  
  vec3 fragcolor = vec3(0);
  
  if (depth < 1.0)
  {  
    vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
    vec3 normal = world_normal(texelFetch(normalmap, ivec3(xy, 0), 0).xyz);
    vec3 eyevec = normalize(scene.camera.position - position); 

    Material material = unpack_material(texelFetch(rt0map, ivec3(xy, 0), 0), texelFetch(rt1map, ivec3(xy, 0), 0)); 

    float ambientocclusion = ambient_intensity(scene.mainlight, ssaomap, vec2(xy)/viewport);

    float mainlightshadow = shadow_intensity(scene.mainlight, scene.shadowview, shadowmap, position, normal);

    vec2 envbrdf = texture(envbrdfmap, vec3(dot(normal, eyevec), material.roughness, 0.0)).rg;
    
    vec3 envdiffuse = textureLod(envmap[0], normal * vec3(1, -1, -1), 6.3).rgb;
    vec3 envspecular = textureLod(envmap[0], reflect(-eyevec, normal) * vec3(1, -1, -1), material.roughness * 8.0).rgb;
    
    vec3 diffuse = vec3(0);
    vec3 specular = vec3(0);

    env_light(diffuse, specular, material, envdiffuse, envspecular, envbrdf);

    main_light(diffuse, specular, scene.mainlight, normal, eyevec, material, ambientocclusion, mainlightshadow);

    for(uint i = 0, end = scene.pointlightcount; i < end; ++i)
    {
      PointLight pointlight = scene.pointlights[i];

      if (length(pointlight.position - position) < pointlight.attenuation.w)
      {
        point_light(diffuse, specular, pointlight, position, normal, eyevec, material);
      }
    }

    fragcolor = scene.camera.exposure * (diffuse * material.diffuse + specular);
  }

  imageStore(dest, xy, vec4(fragcolor, 1));
}

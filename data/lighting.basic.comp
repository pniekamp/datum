#version 450 core
#include "camera.glsl"
#include "gbuffer.glsl"
#include "transform.glsl"
#include "lighting.glsl"

#define SIZE 16

layout(local_size_x = SIZE, local_size_y = SIZE) in;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 prevview;
  mat4 skyview;
  
  Camera camera;

  vec3 noise[16];
  vec3 kernel[16];

  mat4 shadowview[4];
  
  MainLight mainlight;
  
  uint environmentcount;
  Environment environments[6];

  uint pointlightcount;
  PointLight pointlights[256];

} scene;

layout(set=0, binding=1) uniform sampler2DArray rt0map;
layout(set=0, binding=2) uniform sampler2DArray rt1map;
layout(set=0, binding=3) uniform sampler2DArray normalmap;
layout(set=0, binding=4) uniform sampler2DArray depthmap;
layout(set=0, binding=5) uniform sampler2DArray ssaomap;
layout(set=0, binding=6) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=7) uniform samplerCube envmap[6];
layout(set=0, binding=8) uniform sampler2DArray envbrdfmap;

layout(set=3, binding=0) writeonly uniform image2D dest;

///////////////////////// main //////////////////////////////////////////////
void main(void)
{ 
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = imageSize(dest);
  
  float depth = texelFetch(depthmap, ivec3(xy, 0), 0).z;
  
  vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
  vec3 normal = world_normal(texelFetch(normalmap, ivec3(xy, 0), 0).xyz);
  vec3 eyevec = normalize(scene.camera.position - position); 

  Material material = unpack_material(texelFetch(rt0map, ivec3(xy, 0), 0), texelFetch(rt1map, ivec3(xy, 0), 0)); 

  float ambientocclusion = ambient_intensity(scene.mainlight, ssaomap, vec2(xy)/viewport);

  float mainlightshadow = shadow_intensity(scene.mainlight, scene.shadowview, shadowmap, position, normal);

  vec2 envbrdf = texture(envbrdfmap, vec3(dot(normal, eyevec), material.smoothness, 0.0)).rg;
  
  vec3 envdiffuse = textureLod(envmap[0], normal * vec3(1, -1, -1), 6.3).rgb;
  vec3 envspecular = textureLod(envmap[0], reflect(-eyevec, normal) * vec3(1, -1, -1), (1 - material.smoothness) * 8.0).rgb;
  
  vec3 diffuse = vec3(0);
  vec3 specular = vec3(0);

  env_light(diffuse, specular, material, envdiffuse, envspecular, envbrdf);

  main_light(diffuse, specular, scene.mainlight, normal, eyevec, material, ambientocclusion, mainlightshadow);

  for(uint i = 0, end = scene.pointlightcount; i < end; ++i)
  {
    PointLight pointlight = scene.pointlights[i];

    if (length(pointlight.position - position) < pointlight.attenuation.w)
    {
      point_light(diffuse, specular, pointlight, position, normal, eyevec, material);
    }
  }

  vec3 fragcolor = diffuse * material.diffuse + specular;

  imageStore(dest, xy, vec4(tonemap(scene.camera.exposure * fragcolor), 1));
}

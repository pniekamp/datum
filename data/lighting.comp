#version 440 core
#include "bound.glsl"
#include "camera.glsl"
#include "gbuffer.glsl"
#include "transform.glsl"
#include "lighting.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(local_size_x_id = 1, local_size_y_id = 2) in;

layout(std430, set=0, binding=0, row_major) readonly buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 worldview;
  mat4 prevview;
  mat4 skyview;
  vec4 viewport;

  Camera camera;
  
  MainLight mainlight;

  uint environmentcount;
  Environment environments[MaxEnvironments];

  uint pointlightcount;
  PointLight pointlights[MaxPointLights];

  uint spotlightcount;
  SpotLight spotlights[MaxSpotLights];

  Cluster cluster[];
  
} scene;

layout(set=0, binding=1) uniform sampler2D rt0map;
layout(set=0, binding=2) uniform sampler2D rt1map;
layout(set=0, binding=3) uniform sampler2D normalmap;
layout(set=0, binding=4) uniform sampler2D depthmap;
layout(set=0, binding=5) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=6) uniform sampler2DArray envbrdfmap;
layout(set=3, binding=2) uniform samplerCube envmap[MaxEnvironments];
layout(set=3, binding=5) uniform sampler2D ssaomap;

layout(set=3, binding=1) writeonly uniform image2D dest;

///////////////////////// mainlight_shadow //////////////////////////////////
float mainlight_shadow(MainLight light, vec3 position, vec3 normal)
{
  const float bias[ShadowSlices] = { 0.05, 0.06, 0.10, 0.25 };
  const float spread[ShadowSlices] = { 1.5, 1.2, 1.0, 0.2 };

  for(uint i = 0; i < ShadowSlices; ++i)
  {
    vec3 shadowpos = position + bias[i] * normal;
    vec4 shadowspace = scene.mainlight.shadowview[i] * vec4(shadowpos, 1);
    
    vec4 texel = vec4(0.5 * shadowspace.xy + 0.5, i, shadowspace.z);

    if (texel.x > 0.0 && texel.x < 1.0 && texel.y > 0.0 && texel.y < 1.0 && texel.w > 0.0 && texel.w < 1.0)
    { 
      float weight = max(4 * max(max(abs(shadowspace.x), abs(shadowspace.y)) - 0.75, 0), 500 * max(shadowspace.z - 0.998, 0));

      if (i+i < ShadowSlices && weight > 0)
      {     
        return mix(shadow_intensity(scene.mainlight.shadowview[i], shadowpos, i, shadowmap, spread[i]), shadow_intensity(scene.mainlight.shadowview[i+1], position + bias[i+1] * normal, i+1, shadowmap, spread[i+1]), weight);
      }
      else
      {
        return shadow_intensity(scene.mainlight.shadowview[i], shadowpos, i, shadowmap, spread[i]);
      }     
    }
  }
  
  return 1.0;
}
  
///////////////////////// main //////////////////////////////////////////////
void main()
{ 
  gl_WorkGroupSize;
  
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = textureSize(depthmap, 0).xy;//imageSize(dest);
  
  float depth = texelFetch(depthmap, xy, 0).r;

  vec4 fragcolor = vec4(0);
  
  if (depth < 1.0)
  {
    vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
    vec3 normal = world_normal(texelFetch(normalmap, xy, 0).xyz);
    vec3 eyevec = normalize(scene.camera.position - position);
    
    uint tile = cluster_tile(xy, viewport);
    uint tilez = cluster_tilez(depth);

    MainLight mainlight = scene.mainlight;
    
    Material material = unpack_material(texelFetch(rt0map, xy, 0), texelFetch(rt1map, xy, 0)); 

    vec3 diffuse = vec3(0);
    vec3 specular = vec3(0);
    
    //
    // Environment Lighting
    //

    vec3 envdiffuse = vec3(0.2);
    vec3 envspecular = vec3(0);

    float ambientintensity = ambient_intensity(mainlight, ssaomap, xy, viewport);
    
    if (ambientintensity != 0)
    {    
      vec3 diffusedirection = dffuse_dominantdirection(normal, eyevec, material.roughness);
      vec3 speculardirection = specular_dominantdirection(normal, reflect(-eyevec, normal), material.roughness);
      
      for(uint im = scene.cluster[tile].environmentmask[tilez], i = findLSB(im); im != 0; im ^= (1 << i), i = findLSB(im))
      {
        Environment environment = scene.environments[i];

        vec3 localpos = transform_multiply(environment.invtransform, position);
        vec3 localdiffuse = quaternion_multiply(environment.invtransform.real, diffusedirection);
        vec3 localspecular = quaternion_multiply(environment.invtransform.real, speculardirection);
        
        vec2 hittest = intersections(localpos, localspecular, environment.halfdim);
        
        if (hittest.y > max(hittest.x, 0) && hittest.x < 0)
        { 
          vec3 localray = localpos + hittest.y * localspecular;
          float localroughness = clamp(material.roughness * hittest.y / length(localray), 0, material.roughness);     

          envdiffuse = textureLod(envmap[i], localdiffuse * vec3(1, -1, -1), 6.3).rgb;        
          envspecular = textureLod(envmap[i], localray * vec3(1, -1, -1), localroughness * 8.0).rgb;
          
          break;
        }
      }
    
      vec2 envbrdf = texture(envbrdfmap, vec3(dot(normal, eyevec), material.roughness, 0)).rg;

      env_light(diffuse, specular, material, envdiffuse, envspecular, envbrdf, ambientintensity);
    }

    //
    // Main Light
    //

    float mainlightshadow = mainlight_shadow(mainlight, position, normal);
    
    if (mainlightshadow != 0)
    {      
      main_light(diffuse, specular, mainlight, normal, eyevec, material, mainlightshadow);
    }
   
    //
    // Point Lights
    //
    
    for(uint jm = scene.cluster[tile].pointlightmask[tilez], j = findLSB(jm); jm != 0; jm ^= (1 << j), j = findLSB(jm))
    {
      for(uint im = scene.cluster[tile].pointlightmasks[tilez][j], i = findLSB(im); im != 0; im ^= (1 << i), i = findLSB(im))
      {
        PointLight pointlight = scene.pointlights[(j << 5) + i];
        
        point_light(diffuse, specular, pointlight, position, normal, eyevec, material);
      }
    }
    
    //
    // Spot Lights
    //
    
    for(uint jm = scene.cluster[tile].spotlightmask[tilez], j = findLSB(jm); jm != 0; jm ^= (1 << j), j = findLSB(jm))
    {
      for(uint im = scene.cluster[tile].spotlightmasks[tilez][j], i = findLSB(im); im != 0; im ^= (1 << i), i = findLSB(im))
      {
        SpotLight spotlight = scene.spotlights[(j << 5) + i];
        
        spot_light(diffuse, specular, spotlight, position, normal, eyevec, material, 1.0);
      }
    }    

    fragcolor = vec4(scene.camera.exposure * ((diffuse + material.emissive) * material.diffuse + specular), 0);
  }

  imageStore(dest, xy, fragcolor); 
}

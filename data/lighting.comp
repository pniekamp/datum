#version 450 core
#include "bound.glsl"
#include "camera.glsl"
#include "gbuffer.glsl"
#include "transform.glsl"
#include "lighting.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(local_size_x_id = 1, local_size_y_id = 2) in;

layout(constant_id = 46) const uint ShadowSlices = 4;
layout(constant_id = 29) const uint MaxPointLights = 256;
layout(constant_id = 31) const uint MaxEnvironments = 6;
layout(constant_id = 72) const uint MaxTileLights = 48;

const uint SizeX = gl_WorkGroupSize.x;
const uint SizeY = gl_WorkGroupSize.y;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 worldview;
  mat4 prevview;
  mat4 skyview;
  vec4 viewport;

  Camera camera;
  
  MainLight mainlight;

  float splits[4];
  mat4 shadowview[4];
  
  uint environmentcount;
  Environment environments[MaxEnvironments];

  uint pointlightcount;
  PointLight pointlights[MaxPointLights];

} scene;

layout(set=0, binding=1) uniform sampler2D rt0map;
layout(set=0, binding=2) uniform sampler2D rt1map;
layout(set=0, binding=3) uniform sampler2D normalmap;
layout(set=0, binding=4) uniform sampler2D depthmap;
layout(set=0, binding=5) uniform sampler2D ssaomap;
layout(set=0, binding=6) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=7) uniform sampler2DArray envbrdfmap;
layout(set=0, binding=8) uniform samplerCube envmap[MaxEnvironments];

layout(set=3, binding=1) writeonly uniform image2D dest;

shared uint maxdepth;
shared uint minhdepth;
shared uint maxhdepth;
shared uint mindepth;
shared uint pln[2];
shared uint plids[2][MaxTileLights];

///////////////////////// asuint ////////////////////////////////////////////
uint asuint(float value)
{
  return uint(value * float(0x7F7FFFFF));
}

///////////////////////// asfloat ///////////////////////////////////////////
float asfloat(uint value)
{
  return float(value) / float(0x7F7FFFFF);
}

///////////////////////// mainlight_shadow //////////////////////////////////
float mainlight_shadow(MainLight light, vec3 position, vec3 normal)
{
  const float bias[ShadowSlices] = { 0.05, 0.06, 0.10, 0.25 };
  const float spread[ShadowSlices] = { 1.5, 1.2, 1.0, 0.2 };

  for(uint i = 0; i < ShadowSlices; ++i)
  {
    vec3 shadowpos = position + bias[i] * normal;
    vec4 shadowspace = scene.shadowview[i] * vec4(shadowpos, 1);
    
    vec4 texel = vec4(0.5 * shadowspace.xy + 0.5, i, shadowspace.z);

    if (texel.x > 0.0 && texel.x < 1.0 && texel.y > 0.0 && texel.y < 1.0 && texel.w > 0.0 && texel.w < 1.0)
    { 
      float weight = max(4 * max(max(abs(shadowspace.x), abs(shadowspace.y)) - 0.75, 0), 500 * max(shadowspace.z - 0.998, 0));

      if (i+i < ShadowSlices && weight > 0)
      {     
        return mix(shadow_intensity(scene.shadowview[i], shadowpos, i, shadowmap, spread[i]), shadow_intensity(scene.shadowview[i+1], position + bias[i+1] * normal, i+1, shadowmap, spread[i+1]), weight);
      }
      else
      {
        return shadow_intensity(scene.shadowview[i], shadowpos, i, shadowmap, spread[i]);
      }     
    }
  }
  
  return 1.0;
}

///////////////////////// environment  ///////////////////////////////////////
void environment(inout vec3 envdiffuse, inout vec3 envspecular, vec3 position, vec3 normal, vec3 eyevec, Material material)
{
  uint i = 0;

  vec3 diffusedirection = dffuse_dominantdirection(normal, eyevec, material.roughness);
  vec3 speculardirection = specular_dominantdirection(normal, reflect(-eyevec, normal), material.roughness);

  for(uint end = max(scene.environmentcount, 1u) - 1; i < end; ++i)
  {
    vec3 localpos = transform_multiply(scene.environments[i].invtransform, position);
    vec3 localdir = quaternion_multiply(scene.environments[i].invtransform.real, speculardirection);
    
    vec2 hittest = intersections(localpos, localdir, scene.environments[i].halfdim);
    
    if (hittest.y > max(hittest.x, 0) && hittest.x < 0)
    { 
      vec3 localray = localpos + hittest.y * localdir;
      float localroughness = clamp(material.roughness * hittest.y / length(localray), 0, material.roughness);
    
      envdiffuse = textureLod(envmap[i], diffusedirection * vec3(1, -1, -1), 6.3).rgb;        
      envspecular = textureLod(envmap[i], localray * vec3(1, -1, -1), localroughness * 8.0).rgb;
      return;
    }
  }

  if (scene.environmentcount != 0)
  {
    vec3 localdir = quaternion_multiply(scene.environments[i].invtransform.real, speculardirection);

    envdiffuse = textureLod(envmap[i], diffusedirection * vec3(1, -1, -1), 6.3).rgb;        
    envspecular = textureLod(envmap[i], localdir * vec3(1, -1, -1), material.roughness * 8.0).rgb;
  }
}
  
///////////////////////// main //////////////////////////////////////////////
void main(void)
{ 
  gl_WorkGroupSize;

  if (gl_LocalInvocationIndex == 0)
  {
    maxdepth = 0x00000000;
    minhdepth = 0xFFFFFFFF;
    maxhdepth = 0x00000000;
    mindepth = 0xFFFFFFFF;
    pln[0] = pln[1] = 0;
  }
  
  barrier();
  
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = textureSize(depthmap, 0).xy;//imageSize(dest);
  
  float depth = texelFetch(depthmap, xy, 0).z;

  float z = -view_depth(scene.proj, depth);

  if (depth < 1.0)  
  {
    atomicMin(mindepth, asuint(depth));
    atomicMax(maxdepth, asuint(depth));
  }

  barrier();
  
  float minz = -view_depth(scene.proj, asfloat(mindepth));
  float maxz = -view_depth(scene.proj, asfloat(maxdepth));

  float halfz = 0.5 * (minz + maxz);

  if (z < halfz)
    atomicMin(minhdepth, asuint(depth));
  else
    atomicMax(maxhdepth, asuint(depth));

  barrier();

  uint nf = (z < halfz) ? 0 : 1;

  float minhz = -view_depth(scene.proj, asfloat(minhdepth));
  float maxhz = -view_depth(scene.proj, asfloat(maxhdepth));
  
  vec2 step = vec2(2.0 * SizeX, 2.0 * SizeY) / viewport;
  vec2 base = vec2(gl_WorkGroupID.xy) * step - 1;
  
  Bound2 tile = make_bound((scene.invproj * vec4(base, -1, 1)).xy, (scene.invproj * vec4(base + step, -1, 1)).xy);

  Bound3 faraabb = make_bound(tile, minhz, maxz);
  Bound3 nearaabb = make_bound(tile, minz, maxhz);

  for(uint i = gl_LocalInvocationIndex, end = scene.pointlightcount; i < end; i += SizeX*SizeY)
  {
    vec3 lightposition = view_position(scene.view, scene.pointlights[i].position);
    float lightradius = scene.pointlights[i].attenuation.w + 1;

    if (intersects(faraabb, lightposition, lightradius))
    {
      uint index = atomicAdd(pln[0], 1);
      
      if (index < MaxTileLights)
        plids[0][index] = i;
    }

    if (intersects(nearaabb, lightposition, lightradius))
    {
      uint index = atomicAdd(pln[1], 1);
      
      if (index < MaxTileLights)
        plids[1][index] = i;
    }
  }
  
  barrier();

  vec4 fragcolor = vec4(0);
  
  if (depth < 1.0)
  {
    vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
    vec3 normal = world_normal(texelFetch(normalmap, xy, 0).xyz);
    vec3 eyevec = normalize(scene.camera.position - position);

    Material material = unpack_material(texelFetch(rt0map, xy, 0), texelFetch(rt1map, xy, 0)); 

    vec2 envbrdf = texture(envbrdfmap, vec3(dot(normal, eyevec), material.roughness, 0)).rg;

    float ambientintensity = ambient_intensity(scene.mainlight, ssaomap, xy, viewport);

    float mainlightshadow = mainlight_shadow(scene.mainlight, position, normal);
    
    vec3 envdiffuse = vec3(0.2);
    vec3 envspecular = vec3(0);

    environment(envdiffuse, envspecular, position, normal, eyevec, material);

    vec3 diffuse = vec3(0);
    vec3 specular = vec3(0);

    env_light(diffuse, specular, material, envdiffuse, envspecular, envbrdf, ambientintensity);
    
    main_light(diffuse, specular, scene.mainlight, normal, eyevec, material, mainlightshadow);
    
    for(uint i = 0, end = min(pln[nf], MaxTileLights); i < end; ++i)
    {
      PointLight pointlight = scene.pointlights[plids[nf][i]];

      point_light(diffuse, specular, pointlight, position, normal, eyevec, material);
    }

    fragcolor = vec4(scene.camera.exposure * ((diffuse + material.emissive) * material.diffuse + specular), 0);       
  }

  imageStore(dest, xy, fragcolor); 
}

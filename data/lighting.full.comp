#version 450 core
#include "bound.glsl"
#include "camera.glsl"
#include "transform.glsl"
#include "gbuffer.glsl"
#include "lighting.glsl"

#define SIZE 16

layout(local_size_x = SIZE, local_size_y = SIZE) in;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 prevview;
  mat4 skyview;
  
  Camera camera;

  vec3 noise[16];
  vec3 kernel[16];

  mat4 shadowview[4];
  
  MainLight mainlight;
  
  uint environmentcount;
  Environment environments[6];

  uint pointlightcount;
  PointLight pointlights[256];

} scene;

layout(set=0, binding=1) uniform sampler2DArray albedomap;
layout(set=0, binding=2) uniform sampler2DArray specularmap;
layout(set=0, binding=3) uniform sampler2DArray normalmap;
layout(set=0, binding=4) uniform sampler2DArray depthmap;
layout(set=0, binding=5) uniform sampler2DArray ssaomap;
layout(set=0, binding=6) uniform sampler2DArrayShadow shadowmap;
layout(set=0, binding=7) uniform samplerCube envmap[6];
layout(set=0, binding=8) uniform sampler2DArray envbrdf;

layout(set=3, binding=0) writeonly uniform image2D dest;

#define MAX_TILE_LIGHTS 128u

shared uint maxdepth;
shared uint minhdepth;
shared uint maxhdepth;
shared uint mindepth;
shared uint pln[2];
shared uint plids[2][MAX_TILE_LIGHTS];

///////////////////////// asuint ////////////////////////////////////////////
uint asuint(float value)
{
  return uint(value * float(0x7F7FFFFF));
}

///////////////////////// asfloat ///////////////////////////////////////////
float asfloat(uint value)
{
  return float(value) / float(0x7F7FFFFF);
}

///////////////////////// main //////////////////////////////////////////////
void main(void)
{ 
  if (gl_LocalInvocationIndex == 0)
  {
    maxdepth = 0x00000000;
    minhdepth = 0xFFFFFFFF;
    maxhdepth = 0x00000000;
    mindepth = 0xFFFFFFFF;
    pln[0] = pln[1] = 0;
  }
  
  barrier();
  
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 viewport = imageSize(dest);
  
  float depth = texelFetch(depthmap, ivec3(xy, 0), 0).z;

  float z = -view_depth(scene.proj, depth);

  if (depth < 1.0f)  
  {
    atomicMin(mindepth, asuint(depth));
    atomicMax(maxdepth, asuint(depth));
  }

  barrier();
  
  float minz = -view_depth(scene.proj, asfloat(mindepth));
  float maxz = -view_depth(scene.proj, asfloat(maxdepth));

  float halfz = 0.5 * (minz + maxz);

  if (z < halfz)
    atomicMin(minhdepth, asuint(depth));
  else
    atomicMax(maxhdepth, asuint(depth));

  barrier();

  uint nf = (z < halfz) ? 0 : 1;

  float minhz = -view_depth(scene.proj, asfloat(minhdepth));
  float maxhz = -view_depth(scene.proj, asfloat(maxhdepth));
  
  vec2 step = vec2(2.0 * SIZE) / viewport;
  vec2 base = vec2(gl_WorkGroupID.xy) * step - 1.0;
  
  Bound2 tile = make_bound((scene.invproj * vec4(base, -1.0, 1.0)).xy, (scene.invproj * vec4(base + step, -1.0, 1.0)).xy);

  Bound3 faraabb = make_bound(tile, minhz, maxz);
  Bound3 nearaabb = make_bound(tile, minz, maxhz);

  for(uint i = gl_LocalInvocationIndex, end = scene.pointlightcount; i < end; i += SIZE*SIZE)
  {
    vec3 lightposition = view_position(scene.view, scene.pointlights[i].position);
    float lightradius = scene.pointlights[i].attenuation.w;

    if (intersects(faraabb, lightposition, lightradius))
    {
      uint index = atomicAdd(pln[0], 1);
      
      if (index < MAX_TILE_LIGHTS)
        plids[0][index] = i;
    }

    if (intersects(nearaabb, lightposition, lightradius))
    {
      uint index = atomicAdd(pln[1], 1);
      
      if (index < MAX_TILE_LIGHTS)
        plids[1][index] = i;
    }
  }
  
  barrier();

  vec3 position = world_position(scene.invview, scene.proj, scene.invproj, xy, viewport, depth);
  vec3 normal = world_normal(texelFetch(normalmap, ivec3(xy, 0), 0).xyz);
  vec3 eyevec = normalize(scene.camera.position - position);
  
  vec4 albedocolor = texelFetch(albedomap, ivec3(xy, 0), 0);
  vec4 specularcolor = texelFetch(specularmap, ivec3(xy, 0), 0);

  float specularexponent = 1000.0 * specularcolor.w;

  float ambientocclusion = ambient_intensity(scene.mainlight, ssaomap, vec2(xy)/viewport);

  float mainlightshadow = shadow_intensity(scene.mainlight, scene.shadowview, shadowmap, position, normal);

  for(uint i = 0, end = scene.environmentcount; i < end; ++i)
  {
    vec4 ll = scene.environments[i].clipview * vec4(position, 1);
    
    if (ll.x > -1 && ll.x < 1 && ll.y > -1 && ll.y < 1 && ll.z > -1 && ll.z < 1)
    {
      specularcolor.rgb *= texture(envmap[i], quaternion_multiply(scene.environments[i].rotation, reflect(-eyevec, normal)) * vec3(1, -1, -1)).rgb;
    
      break;
    }
  }
  
  vec3 diffuse = vec3(0);
  vec3 specular = vec3(0);

  main_light(diffuse, specular, scene.mainlight, normal, eyevec, albedocolor.rgb, specularcolor.rgb, specularexponent, ambientocclusion, mainlightshadow);

  for(uint i = 0, end = min(pln[nf], MAX_TILE_LIGHTS); i < end; ++i)
  {
    PointLight pointlight = scene.pointlights[plids[nf][i]];

    point_light(diffuse, specular, pointlight, position, normal, eyevec, albedocolor.rgb, specularcolor.rgb, specularexponent);
  }

  vec3 fragcolor = diffuse + specular;

  imageStore(dest, xy, vec4(tonemap(scene.camera.exposure * fragcolor), 1.0));
}

#version 440 core
#include "transform.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

/*layout(constant_id = 57) */const uint WaveResolution = 64;

layout(std430, set=0, binding=0, row_major) buffer OceanParams 
{ 
  mat4 proj;
  mat4 invproj;
  Transform camera;

  vec4 plane;
  float swelllength;
  float swellamplitude;
  float swellsteepness;
  float swellphase;
  vec2 swelldirection;

  float scale;
  float choppiness;
  float smoothing;
  
  uint size;
  vec2 h0[WaveResolution*WaveResolution];
  float phase[WaveResolution*WaveResolution];

  uint sizex;
  uint sizey;  

} params;

layout(std430, set=0, binding=1, row_major) buffer Spectrum 
{
  vec2 h[WaveResolution*WaveResolution];
  vec2 hx[WaveResolution*WaveResolution];
  vec2 hy[WaveResolution*WaveResolution];

  float weights[WaveResolution*WaveResolution];

} spectrum;

layout(set=0, binding=3) uniform sampler2DArray displacementmap;

struct Vertex
{
  float position[3];
  float texcoord[2];
  float normal[3];
  float tangent[4];
};

layout(std430, set=0, binding=4, row_major) buffer VertexBuffer 
{
  Vertex vertices[];

} vertexbuffer;

#define PI 3.1415926535897932384626433832795

///////////////////////// main //////////////////////////////////////////////
void main()
{ 
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);

  uint index = xy.y * params.sizex + xy.x;

  vec3 camerapos = 2 * quaternion_multiply(params.camera.dual, quaternion_conjugate(params.camera.real)).yzw;

  float cameraheight = dot(params.plane.xyz, camerapos) + params.plane.w;

  float margin = 1 + sqrt((2*params.swellamplitude + 0.5) / cameraheight);

  float u = (2 * float(xy.x) / (params.sizex-1) - 1) * margin;
  float v = (1 - 2 * float(xy.y) / (params.sizey-1)) * margin;

  vec4 viewvec = params.invproj * vec4(u, v, 0.0f, 1.0f);
  vec3 worlddir = quaternion_multiply(params.camera.real, normalize(viewvec.xyz));

  float costheta = dot(worlddir, -params.plane.xyz);

  float dist = (costheta > 0) ? cameraheight/costheta : 1e6;

  vec3 position = vec3(camerapos.xy + dist * worlddir.xy, -params.plane.w);

  float amplitude = params.swellamplitude;
  float frequency = 2 * PI / params.swelllength;
  vec2 direction = params.swelldirection;
  float qi = params.swellsteepness / (frequency * amplitude * 4 + 1e-6);

  float phi = frequency * amplitude;
  float theta = frequency * dot(direction, position.xy) + params.swellphase;

  position += vec3(qi * amplitude * direction * cos(theta), amplitude * sin(theta));

  vec3 normal = vec3(phi * direction * cos(theta)/6, qi * phi * sin(theta));
  vec3 tangent = vec3(qi * phi * direction * direction.y * sin(theta)/6, phi * direction.y * cos(theta));

  mat3 tbn;
  tbn[2] = normalize(vec3(-normal.x, -normal.y, 1 - normal.z));
  tbn[0] = normalize(vec3(-tangent.x, 1 - tangent.y, tangent.z));
  tbn[1] = cross(tbn[2], tbn[0]);

  vec2 texcoord = position.xy * params.scale;

  vec4 displacement = texture(displacementmap, vec3(texcoord, 0));
  vec4 displacementnormal = texture(displacementmap, vec3(texcoord, 1));

  normal = mix(tbn * displacementnormal.xyz, vec3(0, 0, 1), pow(clamp(dist * params.smoothing, 0.0f, 1.0f), 0.2));

  vertexbuffer.vertices[index].position[0] = position.x - displacement.x;
  vertexbuffer.vertices[index].position[1] = position.y - displacement.y;
  vertexbuffer.vertices[index].position[2] = position.z + displacement.z;

  vertexbuffer.vertices[index].normal[0] = normal.x;
  vertexbuffer.vertices[index].normal[1] = normal.y;
  vertexbuffer.vertices[index].normal[2] = normal.z;

  vertexbuffer.vertices[index].tangent[0] = tangent.x;
  vertexbuffer.vertices[index].tangent[0] = tangent.y;
  vertexbuffer.vertices[index].tangent[0] = tangent.z;
  vertexbuffer.vertices[index].tangent[0] = 1;

  vertexbuffer.vertices[index].texcoord[0] = 0.1*position.x;
  vertexbuffer.vertices[index].texcoord[1] = 0.1*position.y;
}

#version 450 core
#include "camera.glsl"
#include "gbuffer.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(local_size_x_id = 1, local_size_y_id = 2) in;

layout(constant_id = 67) const uint Radius = 2;
layout(constant_id = 62) const uint NoiseSize = 16;
layout(constant_id = 63) const uint KernelSize = 16;

const uint SizeX = gl_WorkGroupSize.x - Radius - Radius;
const uint SizeY = gl_WorkGroupSize.y - Radius - Radius;

layout(std430, set=0, binding=0, row_major) buffer SceneSet 
{
  mat4 proj;
  mat4 invproj;
  mat4 view;
  mat4 invview;
  mat4 prevview;
  mat4 skyview;
  
  Camera camera;

} scene;

layout(std430, set=3, binding=0, row_major) buffer ComputeSet 
{
  vec3 noise[NoiseSize];
  vec3 kernel[KernelSize];

  float luminance;

} compute;

layout(set=0, binding=1) uniform sampler2DArray rt0map;
layout(set=0, binding=2) uniform sampler2DArray rt1map;
layout(set=0, binding=3) uniform sampler2DArray normalmap;
layout(set=0, binding=4) uniform sampler2DArray depthmap;
layout(set=0, binding=5) uniform sampler2DArray prevmap;

layout(set=3, binding=1) writeonly uniform image2D dest;

const float OcclusionRadius = 0.35;
const float OcclusionPower = 1.5;
const float OcclusionBias = 0.1;

shared float texels[SizeY + Radius + Radius][SizeX + Radius + Radius];
shared float depths[SizeY + Radius + Radius][SizeX + Radius + Radius];

///////////////////////// max_element ///////////////////////////////////////
float max_element(vec4 value)
{
  return max(value.x, max(value.y, max(value.z, value.w)));
}

///////////////////////// main //////////////////////////////////////////////
void main()
{ 
  ivec2 ij = ivec2(gl_LocalInvocationID.xy);
  ivec2 xy = ivec2(gl_WorkGroupID.x * SizeX + ij.x - Radius, gl_WorkGroupID.y * SizeY + ij.y - Radius);
  
  vec2 texcoord = vec2(xy + 0.5) / textureSize(prevmap, 0).xy;//imageSize(dest);

  vec4 depthquad = textureGather(depthmap, vec3(texcoord, 0));
  
  float depth = max_element(mix(vec4(0), depthquad, lessThan(depthquad, vec4(1))));
  
  vec3 position = view_position(scene.proj, scene.invproj, texcoord, depth);
  vec3 normal = view_normal(scene.view, texture(normalmap, vec3(texcoord, 0)).xyz);
  
  vec3 randomvec = compute.noise[(xy.x + xy.y * 4) % NoiseSize];

  vec3 tangent = normalize(randomvec - normal * dot(randomvec, normal));
  vec3 bitangent = cross(normal, tangent);
  
  mat3 tbnview = mat3(tangent, bitangent, normal);

  float occlusion = 0.0;

  for(uint i = 0; i < KernelSize; ++i)
  {
    vec3 samplepos = position + tbnview * compute.kernel[i] * OcclusionRadius;
    
    float sampledepth = view_depth(scene.proj, texture(depthmap, vec3(0.5 * project(scene.proj, samplepos) + 0.5, 0)).r);

    float rangecheck = smoothstep(0.0, 1.0, OcclusionRadius / abs(position.z - -sampledepth));
    
    occlusion += rangecheck * step(samplepos.z, -sampledepth - OcclusionBias);
  }

  occlusion = pow(1.0 - (occlusion / KernelSize), OcclusionPower);

  texels[ij.y][ij.x] = occlusion;
  depths[ij.y][ij.x] = depth;

  barrier();
  
  if (ij.x >= Radius && ij.x < SizeX+Radius && ij.y >= Radius && ij.y < SizeY+Radius)
  {
    float avg = 0;
    float spatialweight = 0;

    for(uint j = ij.y - Radius; j < ij.y + Radius; ++j)
    {
      for(uint i = ij.x - Radius; i < ij.x + Radius; ++i)
      {
        float weight = max(1.0 - 250*abs(depths[j][i] - depth), 0.0);
        
        avg += weight * texels[j][i];
        spatialweight += weight;
      }
    }
    
    occlusion = avg / spatialweight;

    vec2 prevtexcoord = 0.5 * project(scene.proj, (scene.prevview * scene.invview * vec4(position, 1.0)).xyz) + 0.5;

    vec4 prevocclusion = texture(prevmap, vec3(prevtexcoord, 0));
    
    vec3 prevposition = view_position(scene.proj, scene.invproj, prevtexcoord, prevocclusion.y);
    
    float temporalweight = clamp(5.0 * abs(prevocclusion.x - occlusion) + 0.001 * distance(prevposition, position), 0.1, 1.0);

    occlusion = mix(prevocclusion.x, occlusion, temporalweight);
  
    imageStore(dest, xy, vec4(occlusion, depth, 0, 0));
  }
}
